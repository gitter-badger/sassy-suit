@function __modularScale($number, $increment, $ratio){
    $v1: nth($number, 1);
    $v2: nth($number, length($number));
    $value: $v1;

    // scale $v2 to just above $v1
    @while $v2 > $v1 {
        $v2: ($v2 / $ratio); // will be off-by-1
    }
    @while $v2 < $v1 {
        $v2: ($v2 * $ratio); // will fix off-by-1
    }

    // check AFTER scaling $v2 to prevent double-counting corner-case
    $double-stranded: $v2 > $v1;

    @if $increment > 0 {
        @for $i from 1 through $increment {
            @if $double-stranded and ($v1 * $ratio) > $v2 {
                $value: $v2;
                $v2: ($v2 * $ratio);
            } @else {
                $v1: ($v1 * $ratio);
                $value: $v1;
            }
        }
    }

    @if $increment < 0 {
        // adjust $v2 to just below $v1
        @if $double-stranded {
            $v2: ($v2 / $ratio);
        }

        @for $i from $increment through -1 {
            @if $double-stranded and ($v1 / $ratio) < $v2 {
                $value: $v2;
                $v2: ($v2 / $ratio);
            } @else {
                $v1: ($v1 / $ratio);
                $value: $v1;
            }
        }
    }

    @return $value;
}

/**
 * calculates a modular scale based on $ratio
 *
 * @since 1.0.0
 *
 * @requires __modularScale
 * @requires v-invoke
 *
 * @param {number} $number    - the number to apply the modular scale
 * @param {number} $increment - the step(s) for incrementation
 * @param {number} $ratio     - the ratio for the calculation (e.g. 1.618 for golden ratio)
 *
 * @return {number}
 */

@function v-modularScale($number, $increment, $ratio) {
    @return v-invoke(
        $params: ($number, $increment, $ratio),
        $types: (number, number, number),
        $callback: __modularScale
    );
}